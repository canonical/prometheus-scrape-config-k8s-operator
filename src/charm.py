#!/usr/bin/env python3
# Copyright 2021 Canonical Ltd.
# See LICENSE file for licensing details.
#
# Learn more at: https://juju.is/docs/sdk

"""Prometheus Scrape Configuration charm.

The Prometheus Scrape Configuration is a charm that
allows to override configurations for the scrape jobs
generated by charms that provide relations using the
'metrics-endpoint' relation.
"""

import json
import logging
from copy import deepcopy

from charms.prometheus_k8s.v0.prometheus_scrape import MetricsEndpointConsumer
from ops.charm import CharmBase
from ops.main import main
from ops.model import ActiveStatus, BlockedStatus, MaintenanceStatus

logger = logging.getLogger(__name__)


class PrometheusScrapeConfigCharm(CharmBase):
    """PrometheusScrapeConfigCharm is a adapter charm.

    PrometheusScrapeConfigCharm has no real workload. It
    transforms incoming scrape jobs from upstreams (e.g.,
    charms that expose a metrics endpoint) and pushes them
    to downstream to charms that will execute the scraping
    (e.g., Prometheus).
    """

    def __init__(self, *args):
        """Construct the charm, no arguments needed."""
        super().__init__(*args)

        self._target_relation_name = "configurable-scrape-jobs"
        self._prometheus_relation_name = "metrics-endpoint"

        # manages relation with scrape targets
        self._metrics_consumer = MetricsEndpointConsumer(self, self._target_relation_name)

        self.framework.observe(
            self._metrics_consumer.on.targets_changed,
            self._update_all_downstreams,
        )

        self.framework.observe(
            self.on[self._target_relation_name].relation_broken,
            self._handle_upstream_relation_broken,
        )

        # When a new consumer of the metrics-endpoint relation is related,
        # pass it all the current scrape jobs. We register to both the relation
        # being created and joined, because relation_created is not reliably sent
        # over unit recreation.
        self.framework.observe(
            self.on[self._prometheus_relation_name].relation_created,
            self._set_jobs_to_new_downstream,
        )
        self.framework.observe(
            self.on[self._prometheus_relation_name].relation_joined,
            self._set_jobs_to_new_downstream,
        )

        # manages configuration changes for this charm
        self.framework.observe(self.on.config_changed, self._update_all_downstreams)
        # Ensure we refresh scrape jobs on charm upgrade
        self.framework.observe(self.on.upgrade_charm, self._update_all_downstreams)

    def _has_upstream_relations(self):
        return (
            self._target_relation_name not in self.model.relations
            or not self.model.relations[self._target_relation_name]
        )

    def _handle_upstream_relation_broken(self, _):
        """Block the charm when no charms contribute scrape jobs."""
        if not self.unit.is_leader():
            return

        if self._has_upstream_relations():
            self.unit.status = BlockedStatus("upstream relations missing")
            return

    def _set_jobs_to_new_downstream(self, event):
        """Set Prometheus scrape configuration for all targets."""
        if not self.unit.is_leader():
            return

        if self._has_upstream_relations():
            self.unit.status = BlockedStatus("upstream relations missing")
            return

        self.unit.status = MaintenanceStatus(
            "Providing scrape jobs and alert rules to new downstream"
        )

        self._update_downstream_relations([event.relation])

        self.unit.status = ActiveStatus()

    def _update_all_downstreams(self, _):
        """Update all scrape configuration jobs in all downstreams."""
        if not self.unit.is_leader():
            return

        if (
            "metrics-endpoint" not in self.model.relations
            or not self.model.relations["metrics-endpoint"]
        ):
            self.unit.status = BlockedStatus("downstream relations missing")
            return

        self.unit.status = MaintenanceStatus(
            "Updating scrape jobs and alert rules to all downstreams"
        )

        self._update_downstream_relations(self.model.relations[self._prometheus_relation_name])

        self.unit.status = ActiveStatus()

    def _update_downstream_relations(self, downstream_relations):
        if not downstream_relations:
            logger.debug("'_update_downstream_relations': empty list of downstream relations")
            return

        prometheus_configurations = self._prometheus_configurations

        scrape_jobs = json.dumps(prometheus_configurations["scrape_jobs"])
        alert_rules = json.dumps(prometheus_configurations["alert_rules"])

        for downstream_relation in downstream_relations:
            downstream_relation.data[self.app]["scrape_jobs"] = scrape_jobs
            downstream_relation.data[self.app]["alert_rules"] = alert_rules
            logger.debug("Updated downstream %s", downstream_relation.app)

    @property
    def _config(self):
        return {key.replace("-", "_"): value for key, value in self.model.config.items()}

    @property
    def _prometheus_configurations(self):
        config = self._config

        configured_jobs = [
            # Using kwargs to merge in place
            {**deepcopy(upstream_job), **config}
            for upstream_job in self._metrics_consumer.jobs()
        ]

        alert_groups = list(self._metrics_consumer.alerts().values())

        return {"scrape_jobs": configured_jobs, "alert_rules": {"groups": alert_groups}}

    @property
    def _downstream_relations(self):
        if self._prometheus_relation_name in self.model.relations:
            return self.model.relations[self._prometheus_relation_name]

        return []


if __name__ == "__main__":
    main(PrometheusScrapeConfigCharm)
